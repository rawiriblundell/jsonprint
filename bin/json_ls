#!/bin/bash

# A simple GNU-specific demonstration of 'ls' with json output

# A simple aesthetic function to give another name for '.'
# shellcheck disable=SC1090
include() { . "${1}" || exit 1; }

include ../lib/jsonprint.sh

shopt -s dotglob nullglob

# Figure out which checksum method is available, start with sha256sum
if command -v sha256sum > /dev/null 2>&1; then
    get_file_checksum() { sha256sum "${1:?No target specified}" | awk '{print $1}'; }
# Next we try for the digest command i.e. Solaris
elif digest -v -a sha256 "$1" > /dev/null 2>&1; then
    get_file_checksum() { digest -v -a sha256 "${1:?No target specified}" | awk -F '= ' '{print $2}'; }
# If digest won't play nice with sha256, try again with md5
elif digest -v -a md5 "$1" > /dev/null 2>&1; then
    get_file_checksum() { digest -v -a md5 "${1:?No target specified}" | awk -F '= ' '{print $2}'; }
# 'shasum' should cater for AIX hosts, 'csum' may be worth looking at as well
elif shasum -a 256 "$1" > /devnull 2>&1; then
    get_file_checksum() { shasum -a 256 "${1:?No target specified}" | awk '{print $1}'; }
# We can always try for md5sum as well
elif command -v md5sum > /dev/null 2>&1; then
    get_file_checksum() { md5sum "${1:?No target specified}" | awk '{print $1}'; }
# One last try for 'cksum' which should cover more ancient Unices
elif command -v cksum > /dev/null 2>&1; then
    get_file_checksum() { cksum "${1:?No target specified}" | awk '{print $1}'; }
fi

# If we get to this point, let's start building our JSON output
json_open
  json_arr_open "${PWD}"
    json_obj_open
      # We keep a track of how many files are here and how many times we loop
      # This is so that we know not to emit a trailing comma on the last object
      loop_iter=0
      set -- *
      fsobj_count="${#}"
      for fsobj in *; do
        fsobj_type="$(stat -c "%F" "${fsobj}")"
        fsobj_link="$(stat -c "%N" "${fsobj}" | tr -d "'")"
        fsobj_name="$(stat -c "%n" "${fsobj}" | json_str_escape)"
        
        # Read in a formatted sequence from 'stat' and assign to our vars
        while read -r fsobj_uid fsobj_gid fsobj_mode fsobj_size fsobj_mtime fsobj_atime fsobj_birth; do
          # Place those vars into our JSON structure
          json_str fileName "${fsobj_name}"
          json_str_append fileOwner "${fsobj_uid}"
          json_str_append fileGroup "${fsobj_gid}"
          json_num_append fileMode "${fsobj_mode}"
          json_num_append sizeBytes "${fsobj_size}"
          json_num_append fileModified "${fsobj_mtime}"
          json_num_append fileAccessed "${fsobj_atime}"
          (( fsobj_birth > 0 )) && json_num_append fileCreated "${fsobj_birth}"
          json_str_append fileType "${fsobj_type}"
          json_str_append dereference "${fsobj_link}"
          json_str_append checksum "$(get_file_checksum "${fsobj}")"
        done < <(stat -c "%U %G %a %s %Y %X %W" "${fsobj}")
        # As above, track our loop count so that we can appropriately
        # emit the last object without a trailing comma
        (( loop_iter++ ))
      if (( loop_iter < fsobj_count )); then
        json_obj_append
      else
        json_obj_close
      fi
    done
  json_arr_close
json_close
